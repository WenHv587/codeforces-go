# CF1592F1 Alice and Recoloring 1 题解

我们需要把输入的矩阵变成全 $\texttt{W}$ 矩阵。

### 提示 1

由于操作 $2$ 和操作 $3$ 都等价于 $2$ 次操作 $1$，我们可以只关注操作 $1$ 和操作 $4$。

### 提示 2

由于操作 $1$ 最便宜，下面的分析将围绕操作 $1$ 展开。

想一想，如果只有操作 $1$，最少要操作多少次？

从矩形右下角开始思考。

如果右下角是 $\texttt{B}$，那么必须操作，否则无需操作。

对于不是右下角的位置，我们需要计算这个位置被之前的操作翻转了多少次：

- 如果翻转了偶数次，就看当前位置是否为 $\texttt{B}$，是就翻转。
- 如果翻转了奇数次，就看当前位置是否为 $\texttt{W}$，是就翻转（因为 $\texttt{W}$ 翻转奇数次变成 $\texttt{B}$，需要继续翻转）。

翻转次数可以通过**二维后缀和**计算。

### 提示 3

考虑操作 $4$ 对操作 $1$ 的影响：

- 执行 $1$ 次操作 $4$，相当于改变了 $4$ 个位置 $(i,j), (i,m), (n,j), (n,m)$ 的翻转次数的奇偶性。
- 执行 $2$ 次操作 $4$，由于 $(n,m)$ 被翻转两次，相当于没有翻转，所以只改变了 $4+4-2=6$ 个位置的翻转次数的奇偶性。这意味着 $2$ 次操作 $4$ 等价于 $6$ 次操作 $1$。
- 执行 $3$ 次操作 $4$，我们可以把其中的 $2$ 次操作 $4$ 替换成 $6$ 次操作 $1$。
- 对于更多次的操作 $4$ 也同理。替换后，至多剩下 $1$ 次操作 $4$。

所以只需考虑操作 $4$ 能否执行 $1$ 次，也就是能否代替 $4$ 次操作 $1$，从而节省 $1$ 块钱。

如果存在 $(i,j), (i,m), (n,j), (n,m)$ 这 $4$ 个位置都执行了操作 $1$，那么可以用 $1$ 次操作 $4$ 代替，这会让总花费减少 $1$。

也就是说，答案等于操作 $1$ 的执行次数，减去「是否存在上述情况」，存在就把答案减少 $1$。

注意这 $4$ 个位置不能重叠，也就是 $i < n$ 且 $j < m$。

下面代码下标从 $0$ 开始。

代码实现时，可以把 $(i,j)$ 处的字符改成 `\0`，以表示该位置执行了操作 $1$。

AC 代码（Golang）：

```go
package main
import ("bufio";."fmt";"os")

func main() {
	in := bufio.NewReader(os.Stdin)
	var n, m, ans int
	Fscan(in, &n, &m)
	a := make([][]byte, n)
	for i := range a {
		Fscan(in, &a[i])
	}

	suf := make([][]byte, n+1)
	for i := range suf {
		suf[i] = make([]byte, m+1)
	}
	for i := n - 1; i >= 0; i-- {
		for j := m - 1; j >= 0; j-- {
			// 二维后缀异或和
			suf[i][j] = suf[i][j+1] ^ suf[i+1][j] ^ suf[i+1][j+1]
			if suf[i][j] == a[i][j]&1 { // 需要翻转
				ans++
				a[i][j] = 0 // 表示 (i,j) 处执行了操作 1
				suf[i][j] ^= 1
			}
		}
	}

	if a[n-1][m-1] == 0 {
		for _, row := range a[:n-1] {
			for j, x := range row[:m-1] {
				if x == 0 && row[m-1] == 0 && a[n-1][j] == 0 {
					Print(ans - 1) // 用 1 次操作 4 代替 4 次操作 1
					return
				}
			}
		}
	}
	Print(ans)
}
```

**时间复杂度**：$\mathcal{O}(nm)$。

欢迎关注 [B站@灵茶山艾府](https://space.bilibili.com/206214)

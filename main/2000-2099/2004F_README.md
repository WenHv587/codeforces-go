合并操作，每次可以减少一个数字。

分解操作，比如最左边是 $2$，最右边是 $5$，我们分解大的那个数，得到 $3$ 和 $2$。这等价于去掉最左边的数，并修改最右边的数。所以每次操作也可以减少一个数字。

所以两种操作效果是相同的，不妨只考虑合并操作。

长为 $m$ 的子数组 $b$，操作 $m-1$ 次可以变成一个数，此时一定是回文的。

能否减少操作次数呢？

比如 $b=[2,2,1,3]$，左右都可以合并成 $4$，最后得到 $[4,4]$，这样只需操作 $2$ 次而不是 $3$ 次，减少了 $1$ 次操作。

又比如 $b=[2,2,9,1,3]$，左右都可以合并成 $4$，最后得到 $[4,9,4]$，这样只需操作 $2$ 次而不是 $4$ 次，减少了 $2$ 次操作。

一般地，如果前缀 $[0,i]$ 与后缀 $[j,m-1]$ 的元素和相同，那么可以减少 $1$ 次操作。注意前后缀**可以相交**，在 $b=[2,2,9,1,3]$ 这个例子中，我们有 $2+2=1+3$，同时还有 $2+2+9=9+1+3$，所以可以减少 $2$ 次操作。 

考虑贡献法，如果有两个非空子数组 $[i_1,j_1],[i_2,j_2]$ 的元素和相同，那么对于下标从 $i_1$ 到 $j_2$ 的子数组 $b$ 来说，可以减少 $1$ 次操作，对答案的贡献就是 $-1$。

所以只需统计非空子数组和的个数 $\textit{cnt}_s$。遍历到子数组 $[i,j]$ 时，设其元素和为 $s$，那么它与之前统计过的 $\textit{cnt}_s$ 个子数组和相同，对答案的贡献就是 $j-i-\textit{cnt}_s$。其中 $j-i$ 是不考虑相同前后缀时，长为 $j-i+1$ 的子数组所需的操作次数。

```go
package main
import ."fmt"

func main() {
	var T, n int
	for Scan(&T); T > 0; T-- {
		Scan(&n)
		a := make([]int, n)
		for i := range a {
			Scan(&a[i])
		}
		ans := 0
		cnt := map[int]int{}
		for i := 0; i < n; i++ {
			s := 0
			for j := i; j < n; j++ {
				s += a[j] // s 等于从 a[i] 到 a[j] 的子数组和
				ans += j - i - cnt[s]
				cnt[s]++
			}
		}
		Println(ans)
	}
}
```

**时间复杂度**：$\mathcal{O}(n^2)$。

欢迎关注 [B站@灵茶山艾府](https://space.bilibili.com/206214)

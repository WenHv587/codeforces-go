方法一：暴力枚举+最大堆

如果存在 a <= lim，那么答案至少是 1。
下面讨论更大的答案。

按照 b 从小到大排序，那么和式变成 sum(子序列中的 a) + b[i] - b[j]，其中 b[i] 和 b[j] 分别是所选子序列中的最大 b 和最小 b。

枚举 i，然后 j 从 i-1 开始倒着枚举。
此时只需要考虑 sum(子序列中的 a) 的最小值。

做法类似力扣上的维护子数组前 k 小问题（见我的力扣数据结构题单中的堆），
用最大堆维护从 a[j] 到 a[i-1] 中的元素，如果 a[i] + 堆中元素和 + b[i] - b[j] > lim，则弹出堆顶，直到 <= lim。
然后用 (1+堆大小) 更新答案的最大值。

你可能会问：如果出堆时，恰好把 a[j] 出堆了，上面这个不等式不就错了吗？
如果出现这种情况，那么上面这个不等式比我们先前在 j+1 时的不等式的要求更加严格，所以堆的大小不会比先前在 j+1 时的堆的大小更大，所以不会算错。

https://codeforces.com/problemset/submission/1935/271457320

方法二：DP

首先按照 b 从小到大排序。

考虑在前 j 个数对中选 i 个数，且第 i 个数必选。
那么问题变成求 sum(a) + b[i] - b[k] 的最小值，其中 b[k] 是第一个选的数。
由于 b[i] 是固定的，单独提出来，问题变成求 sum(a) - b[k] 的最小值，把它当作 f[i][j] 的值。

初始值：f[1][j] = a[j] - b[j]。
转移：f[i][j] = min{f[i-1][k] + a[i]}，其中 k < j。
这可以用前缀最小值优化。
答案：如果在 f[i] 中，存在 j 满足 f[i][j] + b[j] <= lim，则更新答案为 i。

下面代码中的 i 从 0 开始。
https://codeforces.com/contest/1935/submission/272078233

进一步地，f 的第一个维度可以优化掉。
https://codeforces.com/problemset/submission/1935/272079355
